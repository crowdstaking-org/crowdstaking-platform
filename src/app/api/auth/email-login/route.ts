/**
 * Email/Social Login API Endpoint
 * Handles authentication for ThirdWeb InApp Wallets (Email OTP, Google, etc.)
 * 
 * Unlike wallet signature login, this verifies ThirdWeb session directly
 */

import { NextRequest } from 'next/server'
import { createSession } from '@/lib/auth/sessions'
import { successResponse, errorResponse } from '@/lib/api'
import { supabase } from '@/lib/supabase'

/**
 * POST /api/auth/email-login
 * Authenticates a user via ThirdWeb InApp Wallet (Email OTP, Social Login)
 * 
 * Request body:
 * {
 *   "address": "0x...",  // Wallet address generated by ThirdWeb
 *   "email"?: "user@example.com",  // Optional: Email from InApp Wallet
 *   "authMethod": "email" | "google" | "wallet"  // Auth method used
 * }
 * 
 * Response:
 * - Sets httpOnly cookie 'session_id'
 * - Returns { success: true, address, profile }
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { address, email, authMethod } = body
    
    // Validate required fields
    if (!address) {
      return errorResponse('Missing required field: address', 400)
    }
    
    // Validate Ethereum address format (0x + 40 hex characters)
    if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
      return errorResponse('Invalid Ethereum address format', 400)
    }
    
    // For InApp Wallet logins, we trust ThirdWeb's authentication
    // The client already verified with ThirdWeb's servers
    
    // Check if profile exists, if not create one
    let profile = null
    try {
      const { data: existingProfile } = await supabase
        .from('profiles')
        .select('*')
        .eq('wallet_address', address.toLowerCase())
        .single()
      
      profile = existingProfile
      
      // If no profile exists, create one
      if (!existingProfile) {
        const displayName = email ? email.split('@')[0] : `user_${address.slice(2, 8)}`
        
        const { data: newProfile, error: createError } = await supabase
          .from('profiles')
          .insert({
            wallet_address: address.toLowerCase(),
            display_name: displayName,
            email: email || null,
            auth_method: authMethod || 'email',
            bio: 'New member of CrowdStaking',
            created_at: new Date().toISOString(),
          })
          .select()
          .single()
        
        if (createError) {
          console.error('Failed to create profile:', createError)
          // Continue anyway - profile creation is not critical for auth
        } else {
          profile = newProfile
          
          // Also create profile_stats entry
          await supabase
            .from('profile_stats')
            .insert({
              wallet_address: address.toLowerCase(),
              proposals_submitted: 0,
              proposals_accepted: 0,
              total_earned: '0',
              projects_contributed: 0,
              reputation_score: 0,
            })
            .catch(err => console.error('Failed to create profile_stats:', err))
          
          // Create privacy settings
          await supabase
            .from('profile_privacy')
            .insert({
              wallet_address: address.toLowerCase(),
              show_token_holdings: false,
              show_earnings: false,
              show_wallet_address: false,
              show_activity_feed: true,
              show_github_activity: true,
              allow_follows: true,
              allow_endorsements: true,
            })
            .catch(err => console.error('Failed to create privacy settings:', err))
        }
      } else if (email && !existingProfile.email) {
        // Update profile with email if it doesn't have one
        await supabase
          .from('profiles')
          .update({ 
            email,
            auth_method: authMethod || existingProfile.auth_method || 'email'
          })
          .eq('wallet_address', address.toLowerCase())
        
        profile = { ...existingProfile, email, auth_method: authMethod || existingProfile.auth_method }
      }
    } catch (error) {
      console.error('Profile check/creation error:', error)
      // Continue - authentication can succeed even if profile operations fail
    }
    
    // Create session
    const sessionId = createSession(address.toLowerCase())
    
    // Create response with session cookie
    const response = successResponse({
      message: 'Login successful',
      address: address.toLowerCase(),
      profile: profile || { wallet_address: address.toLowerCase() },
      authMethod: authMethod || 'email',
    })
    
    // Set secure httpOnly cookie
    response.cookies.set('session_id', sessionId, {
      httpOnly: true, // Cannot be accessed by JavaScript (XSS protection)
      secure: process.env.NODE_ENV === 'production', // HTTPS only in production
      sameSite: 'lax', // CSRF protection
      maxAge: 60 * 60 * 24 * 7, // 7 days
      path: '/', // Available site-wide
    })
    
    return response
    
  } catch (error) {
    console.error('Email login error:', error)
    return errorResponse(
      error instanceof Error ? error.message : 'Login failed',
      500
    )
  }
}

